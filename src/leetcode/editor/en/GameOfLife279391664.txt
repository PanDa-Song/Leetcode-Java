// regard the live situation for current and after as a bit
// first number means after, second number means current(left to right)
// ie. 11 = always live; 10 = now die, after live
// all cell in the begining first = 0 
// (because the value of them 0 or 1 can be represent by just one number in bits)

class Solution {
    public void gameOfLife(int[][] board) {
        if(board == null || board.length == 0){
            return;
        }
        
        int m = board.length;
        int n = board[0].length;
        
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                int liveNum = liveNeighbors(board, m, n, i, j);
                
                if(board[i][j] == 1 && liveNum >=2 && liveNum <= 3){
                    board[i][j] = 3; // 01 --> 11
                }
                if(board[i][j] == 0 && liveNum == 3){
                    board[i][j] = 2; // 00 --> 10
                }
            }
        }
        
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                board [i][j] >>= 1;
                // '>>' means for bit number, remove several num on the right side
                //eg. for x = 111000; x >>= 2 --> 1110; x >>= 3 --> 111
                //thus, this step make the board return the 'after' situation
            }
        }
    }
    public int liveNeighbors(int[][] board, int m, int n, int i, int j){
        int liveNum = 0;
        for (int x = Math.max(i - 1, 0); x <= Math.min(i + 1, m - 1); x++) {
            for (int y = Math.max(j - 1, 0); y <= Math.min(j + 1, n - 1); y++) {
                liveNum += board[x][y] & 1;
                // == lives += board[x][y] & 1
            }
        }
        liveNum -= board[i][j] & 1;
        return liveNum;
    }
}
//runtime:0 ms
//memory:35 MB
